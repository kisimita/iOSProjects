{\rtf1\ansi\ansicpg1252\cocoartf1187
\cocoascreenfonts1{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fmodern\fcharset0 Courier;\f2\froman\fcharset0 Times-Roman;
\f3\fnil\fcharset0 Menlo-Regular;\f4\fnil\fcharset0 LucidaGrande;\f5\fnil\fcharset0 Baskerville;
\f6\fnil\fcharset0 Chalkboard;}
{\colortbl;\red255\green255\blue255;\red38\green38\blue38;\red234\green234\blue234;\red255\green249\blue89;
\red234\green226\blue176;\red109\green109\blue109;\red142\green74\blue152;\red130\green123\blue14;\red0\green41\blue57;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{square\}}{\leveltext\leveltemplateid1\'01\uc0\u9642 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs24 \cf0 http://www.raywenderlich.com/tutorials\
\
Note:\
I. why has class method:\
1. Some time it's not necessary to allocate instance for calling a function.\
2. Combine with Singleton pattern\
3. object that return by class method is automatically added to autorelease \
----------------\
Fast enum\
\pard\pardeftab720\sa240

\f1\fs22 \cf0 NSArray *colors = [NSArray arrayWithObjects: @"Black", @"Silver", @"Gray", nil];
\f2\fs24 \

\f1\fs22 for (NSString *color in colors)\uc0\u8232 printf("Consider buying a %s car", [color UTF8String]);
\f2\fs24 \
---------------\
NSLog print object\
\pard\pardeftab720

\f1\fs22 \cf0 NSLog(@\'94Make: %@", make); //%@\
NSLog use description function of object to get the info of object\
So above calling is the same with\
fprintf(stderr, "%s\\n", [[make description] UTF8String]); \
--------\
String\
\pard\pardeftab720\sa240

\f2\fs26 \cf0 Cocoa touch offers an 
\f1\fs22 NSStringFrom 
\f2\fs26 family of functions.These provide a simple way to convert structures to printable strings suitable for logging
\fs24 \
Memory management\
when add an object to auto release pool, system will auto release it when get out function(locally variable)\
-------------\
properties\
\pard\pardeftab720\sa240

\f1\fs22 \cf0 there 
\f2\fs24 2 type of property: rw and readonly\
retained properties are qualified as "retain"\
\pard\pardeftab720

\b\fs32 \cf0 Property Qualifiers: \
\pard\pardeftab720

\f1\b0\fs22 \cf0 readwrite 
\f2\fs26 and 
\f1\fs22 readonly\
\pard\pardeftab720

\f2\fs26 \cf0 The default behavior for properties in ARC is 
\f1\fs22 strong\
\pard\pardeftab720\sa240

\f2\fs26 \cf0 in MRR the default behavior is 
\f1\fs22 assign \
Strong 
\f2\fs26 and 
\f1\fs22 retain 
\f2\fs26 are synonymous; \'93strong\'94 emphasizes the object relationship while \'93retain\'94 places its emphasis on the underlying mechanics\
Use strong properties to hold onto any items that may be referenced through the lifetime of your object
\fs24 \

\fs26 Like MRR\'92s 
\f1\fs22 assign 
\f2\fs26 properties, weak properties do not retain objects or otherwise extend their lifetime.However, weak properties do something that 
\f1\fs22 assign 
\f2\fs26 properties never did.They ensure that if the object being pointed to gets deallocated, the property returns 
\f1\fs22 nil, 
\f2\fs26 not a reference to reclaimed memory. This is known as \'93zeroing\'94 weak references.\
Xcode synthesizes "atomic" properties to automatically lock objects before they are accessed or modified and unlock them after -> multi threads. All methods are synthesized atomically by default
\fs24 \
\pard\pardeftab720

\b\fs32 \cf0 Key-Value Coding\
\pard\pardeftab720\sa240

\b0\fs26 \cf0 Key-value coding allows you to access properties by using strings that store property names. Just as you can access a property by 
\f1\fs22 myObject.propertyName, 
\f2\fs26 you can also retrieve the same value by issuing 
\f1\fs22 [myObject valueForKey:@"propertyName"]
\f2\fs24 \
\pard\pardeftab720

\b\fs32 \cf0 Key-Value Observing\
\pard\pardeftab720\sa240

\b0\fs26 \cf0 Key-value observing (better known as KVO) introduces a way to trigger notifications when object properties change.\
----------------\
\pard\pardeftab720\sa240

\b \cf0 MainStoryboard_iPhone.storyboard and MainStoryboard_iPad.story- board\'97These 
\b0 Interface Builder files create a minimally populated GUI for each platform
\fs24 \
\pard\pardeftab720\sa240

\fs26 \cf0 The view controller element in the dock is called a \'93proxy.\'94 A proxy plays a role in IB but the object that it represents (the view controller) is not itself embedded in the .story- board archive.This proxy represents the object that loads and owns the view
\fs24 \

\fs26 First Responder
\fs24 , 
\fs26 Like the view con- troller, it\'92s a proxy object
\fs24 .
\fs26 It represents the onscreen object that is currently responding to user touches. During the lifetime of an application, the first responder changes as users interact with the screen\
Main function  \
	-> 
\f1\fs22 UIApplicationMain(\'85, "delegate name"): control is passed to delegate\
		-> delegate: that implement controller: create UIViewController add, views... \
			receive "application:didFinishLaunchingWithOptions: 
\f2\fs26 message"\
			-> create window, assign controller to window
\fs24 \
\pard\pardeftab720\sa240

\f1\fs22 \cf0 \uc0\u8232 	\
	
\f2\fs26 \
----------------\
objective-C\
- 
\f0\fs32 \cf2 Instance variables go between @interface Class: Parent \{ .... \}\
- No access is set (protected, public, private). Default is protected\
- The function format is: scope (returnType) methodName: (parameter1Type) parameter1Name;\
\pard\pardeftab720
\cf2 Categories are useful for creating private methods. Since Objective-C has no notion of private/protected/public methods like java does, one has to create categories that hide such functionality. The way this is done is by moving the private methods from your class's header (.h) file to the implementation file (.m). The following is a very brief example of what I mean\
\
- Posing is similar to categories, but with a twist. It allows you to extend a class, and make your subclass pose (in place of) the super class globally. For instance: Say you have NSArrayChild that extends NSArray. If you made NSArrayChild pose for NSArray all your code would begin using the NSArrayChild instead of NSArray automatically\
//\
\pard\pardeftab720

\f3\fs26 \cf2 \cb3 Fraction *frac = [[Fraction alloc] initWithNumerator: 3 denominator: 10];\
\
    // print it\
    printf( "The fraction is: " );\
    [frac print];\
    printf( "\\n" );\
\
    // make FractionB pose as Fraction\
    [FractionB \cf0 \cb4 poseAsClass\cf2 \cb3 : [Fraction class]];\
\
    Fraction *frac2 = [[Fraction alloc] initWithNumerator: 3 denominator: 10];\
\
    // print it\
    printf( "The fraction is: " );\
=>>> out put\
\pard\pardeftab720

\fs32 \cf2 \cb5 The fraction is: 3/10\
The fraction is: (3/10)\
\
- 
\f0 \cb1 A Protocol in Objective-C is identical in functionality to an interface in Java, or a purely virtual class in C++.\
Rather than specifying it like Java or C++ as: Printing *someVar = ( Printing * ) frac; for example, you use the id type with a restricted protocol: id <Printing> var = frac; This allows you to dynamically specify a type that requires multiple protocols, all with one variable. Such as: id <Printing, NSCopying> var = frac;\
\
\pard\pardeftab720\sa380

\b\fs48 \cf2 Dynamic types
\b0\fs32 \

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrs\brdrw40\brdrcf6 \trbrdrl\brdrs\brdrw40\brdrcf6 \trbrdrr\brdrs\brdrw40\brdrcf6 
\clvertalc \clshdrawnil \clwWidth6000\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf6 \clbrdrl\brdrs\brdrw20\brdrcf6 \clbrdrb\brdrs\brdrw20\brdrcf6 \clbrdrr\brdrs\brdrw20\brdrcf6 \clpadt20 \clpadl20 \clpadb20 \clpadr20 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth13100\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf6 \clbrdrl\brdrs\brdrw20\brdrcf6 \clbrdrb\brdrs\brdrw20\brdrcf6 \clbrdrr\brdrs\brdrw20\brdrcf6 \clpadt20 \clpadl20 \clpadb20 \clpadr20 \gaph\cellx8640
\pard\intbl\itap1\tx220\tx720\pardeftab720\li720\fi-720
\ls1\ilvl0\cf2 {\listtext	
\f4 \uc0\u9642 
\f0 	}-(BOOL) isKindOfClass: classObj\cell 
\pard\intbl\itap1\tx220\tx720\pardeftab720\li720\fi-720
\ls1\ilvl0\cf2 {\listtext	
\f4 \uc0\u9642 
\f0 	}is object a descendent or member of classObj\cell \row

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrl\brdrs\brdrw40\brdrcf6 \trbrdrr\brdrs\brdrw40\brdrcf6 
\clvertalc \clshdrawnil \clwWidth6000\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf6 \clbrdrl\brdrs\brdrw20\brdrcf6 \clbrdrb\brdrs\brdrw20\brdrcf6 \clbrdrr\brdrs\brdrw20\brdrcf6 \clpadt20 \clpadl20 \clpadb20 \clpadr20 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth13100\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf6 \clbrdrl\brdrs\brdrw20\brdrcf6 \clbrdrb\brdrs\brdrw20\brdrcf6 \clbrdrr\brdrs\brdrw20\brdrcf6 \clpadt20 \clpadl20 \clpadb20 \clpadr20 \gaph\cellx8640
\pard\intbl\itap1\tx220\tx720\pardeftab720\li720\fi-720
\ls1\ilvl0\cf2 {\listtext	
\f4 \uc0\u9642 
\f0 	}-(BOOL) isMemberOfClass: classObj\cell 
\pard\intbl\itap1\tx220\tx720\pardeftab720\li720\fi-720
\ls1\ilvl0\cf2 {\listtext	
\f4 \uc0\u9642 
\f0 	}is object a member of classObj\cell \row

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrl\brdrs\brdrw40\brdrcf6 \trbrdrr\brdrs\brdrw40\brdrcf6 
\clvertalc \clshdrawnil \clwWidth6000\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf6 \clbrdrl\brdrs\brdrw20\brdrcf6 \clbrdrb\brdrs\brdrw20\brdrcf6 \clbrdrr\brdrs\brdrw20\brdrcf6 \clpadt20 \clpadl20 \clpadb20 \clpadr20 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth13100\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf6 \clbrdrl\brdrs\brdrw20\brdrcf6 \clbrdrb\brdrs\brdrw20\brdrcf6 \clbrdrr\brdrs\brdrw20\brdrcf6 \clpadt20 \clpadl20 \clpadb20 \clpadr20 \gaph\cellx8640
\pard\intbl\itap1\tx220\tx720\pardeftab720\li720\fi-720
\ls1\ilvl0\cf2 {\listtext	
\f4 \uc0\u9642 
\f0 	}-(BOOL) respondsToSelector: selector\cell 
\pard\intbl\itap1\tx220\tx720\pardeftab720\li720\fi-720
\ls1\ilvl0\cf2 {\listtext	
\f4 \uc0\u9642 
\f0 	}does the object have a method named specifiec by the selector\cell \row

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrl\brdrs\brdrw40\brdrcf6 \trbrdrr\brdrs\brdrw40\brdrcf6 
\clvertalc \clshdrawnil \clwWidth6000\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf6 \clbrdrl\brdrs\brdrw20\brdrcf6 \clbrdrb\brdrs\brdrw20\brdrcf6 \clbrdrr\brdrs\brdrw20\brdrcf6 \clpadt20 \clpadl20 \clpadb20 \clpadr20 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth13100\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf6 \clbrdrl\brdrs\brdrw20\brdrcf6 \clbrdrb\brdrs\brdrw20\brdrcf6 \clbrdrr\brdrs\brdrw20\brdrcf6 \clpadt20 \clpadl20 \clpadb20 \clpadr20 \gaph\cellx8640
\pard\intbl\itap1\tx220\tx720\pardeftab720\li720\fi-720
\ls1\ilvl0\cf2 {\listtext	
\f4 \uc0\u9642 
\f0 	}+(BOOL) instancesRespondToSelector: selector\cell 
\pard\intbl\itap1\tx220\tx720\pardeftab720\li720\fi-720
\ls1\ilvl0\cf2 {\listtext	
\f4 \uc0\u9642 
\f0 	}does an object created by this class have the ability to respond to the specified selector\cell \row

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrl\brdrs\brdrw40\brdrcf6 \trbrdrb\brdrs\brdrw40\brdrcf6 \trbrdrr\brdrs\brdrw40\brdrcf6 
\clvertalc \clshdrawnil \clwWidth6000\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf6 \clbrdrl\brdrs\brdrw20\brdrcf6 \clbrdrb\brdrs\brdrw20\brdrcf6 \clbrdrr\brdrs\brdrw20\brdrcf6 \clpadt20 \clpadl20 \clpadb20 \clpadr20 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth13100\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf6 \clbrdrl\brdrs\brdrw20\brdrcf6 \clbrdrb\brdrs\brdrw20\brdrcf6 \clbrdrr\brdrs\brdrw20\brdrcf6 \clpadt20 \clpadl20 \clpadb20 \clpadr20 \gaph\cellx8640
\pard\intbl\itap1\tx220\tx720\pardeftab720\li720\fi-720
\ls1\ilvl0\cf2 {\listtext	
\f4 \uc0\u9642 
\f0 	}-(id) performSelector: selector\cell 
\pard\intbl\itap1\tx220\tx720\pardeftab720\li720\fi-720
\ls1\ilvl0\cf2 {\listtext	
\f4 \uc0\u9642 
\f0 	}invoke the specified selector on the object\cell \lastrow\row
\pard\pardeftab720

\f2\fs24 \cf0 \
\pard\pardeftab720\sa240
\cf0 \
\pard\pardeftab720
\cf0 memory management:\
\pard\pardeftab720

\f0\fs32 \cf2  - constant string is added to the autorelease pool automatically\
- object is created by Class method is added to autorelease pool automatically\
There are two ways to manage memory in Objective-C: 1) retain and release or 2) retain and release/autorelease.\
-------------------------\
There are two kinds of arrays NSArray and NSMutableArray.\
NSArray  initialize an array via the constructor using Obj, Obj, Obj, ..., nil\
\
\pard\pardeftab720\sa240

\f2\fs26 \cf0 Note that for the most part, Objective-C produces shallow copies of collections such as arrays and dictionaries. It copies the structure of the collection, and maintains the addresses for each pointer, but does not perform a deep copy of the items stored within.
\fs24 \
\pard\pardeftab720
\cf0 ---------------------------\
User interface\
\pard\pardeftab720

\f5\i\fs34 \cf0 outlets 
\i0 (instance variables in our \cf7 Controller \cf0 that point to objects in our \cf8 View)\

\i \cf0 actions 
\i0 (methods in our \cf7 Controller \cf0 that are going to be sent to us from our \cf8 View)\
\
\pard\pardeftab720

\f6\fs26 \cf9 Once you put a view into the view hierarchy, you can 
\f3 release 
\f6 your ownership if you want
\fs64 \
\pard\pardeftab720\sa240

\fs26 \cf9 If you want to keep using a view, 
\f3 retain 
\f6 ownership before you send 
\f3 removeFromSuperview 
\f6 Removing a view from the hierarchy immediately causes a 
\f3 release 
\f6 on it (not 
\f3 autorelease\
\pard\pardeftab720

\f6 \cf9 When do we need to 
\f3 release 
\f6 our outlets?\
\pard\pardeftab720\sa240
\cf9 Obviously we need to do it in 
\f3 dealloc.
\f2 \

\f6 But there\'92s another time we need to do it ... when a Controller\'92s 
\f3 view 
\f6 is \'93unloaded\'94(l
\f4 ow memory
\f6 )\
- \
-------------------------\
Graphics 
\f4 cordinates
\f6 \
Unit is point not pixel\
Get number of pixel p
\f4 er point: UIView.contentScaleFactor
\f2 \
\
\pard\pardeftab720\sa240

\f1\fs22 \cf0 \
}